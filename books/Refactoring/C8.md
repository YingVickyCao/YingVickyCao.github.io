# 第 8 章 重新组织你的数据

处理数据

## 8.1 Self Encapsulate Field（自封装值域）

When ：当直接访问一个字段时，但与字段之间的耦合关系逐渐变得笨拙 ：当这个字段权限更改，或者名称更改之后你的客户端代码都需要做相应的改变。  
How ： 这个字段建立设值和取值函数并且只以这些函数来访问字段

- 在这个类中，直接访问还是间接访问字段？  
  用“字段直接访问”：  
   自由灵活访问；  
   代码比较容易阅读。

  用“访问函数间接访问”：  
   通过覆写一个函数从而改变获取数据的方式：因为规则改变了；  
   支持更灵活的数据管理方式，例如延迟初始化。

  延迟初始化：只有在真正使用某值时，才对它初始化。

  如何选择？  
   先使用直接访问方式。直到这种方式带来麻烦，用重构变成间接使用方式。

- 在构造函数中不推荐使用设置函数。  
  设置函数被认为应该在对象创建后才使用。  
  Way 1 ：在构造函数中直接访问字段  
  Way 2 ：单独另建一个初始化函数

## 8.2 Replace Data Value with Object（以对象取代数据值）

When ： 有一个数据项，需要与其他数据和行为一起使用才有意义。  
e.g.,
电话号码 - 区号  
订单 - 客户信息（地址，名称、手机号等）

How : 将数据项变成对象。  
可能需要对 新类使用 Change Value to Reference（179）

![refactoring_c8_2](https://yingvickycao.github.io/img/refactoring_c8_2.jpg)

- 值对象 vs 引用对象 ?  
  值对象(Value Object)：不可修改内容。  
  引用对象(Reference Object)：同一个客户的所有 Order 对象可以共享同一个 Customer 对象。

## 8.3 Change Value to Reference（将值对象改为引用对象）

When ：一个类有多个相等的实例，希望将他们替换为同一个对象。

值对象：  
数值相等，判断两个值对象是否相等，需要重写 equals()和 hashcode() .
内容相等的对象可以有 N 个。  
如果要改变，用另一个对象代替该对象。  
在分布系统和并法系统中，不可变值的对象特别有用。

引用对象：  
用==来检验是否为同一对象。  
一旦修改就影响到所有引用此对象的地方。  
引用对象通常被某种控制，通常是对象池，你必须向控制者请求适当的对象。它们可能造成内存领域之间错综复杂的关联。=> 内存泄露

重构前：  
Custom 对象是值对象时：  
多分订单（Order）属于同一客户（Customer），但是每个 Order 对象拥有各自的 Custom 对象，这些 Custom 对象内容相同。

How ： 值对象 -> 引用对象

重构后：  
Custom 对象是引用对象：  
多分订单（Order）属于同一.
客户（Customer），但是每个 Order 对象共享一个 Custom 对象，每个客户名只对应一个 Customer 对象。  
使用工厂模式提前创建所有 Customer 对象。

## 8.4 Change Reference to Value（将引用对象改为实值对象）

When ： 有一个引用对象，很小且不可变，而不容易管理。  
当引用对象难以使用时，应该将它变为值对象。  
根据实际情况，引用对象 <=> 值对象 经常会互相 转换。  
在分布系统和并发系统中，不可变的值对象特别有用，因为不用考虑同步问题。

How ： 引用对象 -> 值对象  
要把一个引用对象变成值对象，关键：检查它是否不可变？如果不是，不能使用本项重构，因为可变的对象会造成烦人的别名问题。  
去掉工厂和控制实例创建的行为。

## 8.5 Replace Array with Object（以对象取代数组）

When ： 一个数组，它的每个元素代表不同的东西。  
How ： 用对象代替数组。数组中的每个元素用该对象的一个字段表示。  
目的：不是为了提高性能，而是为了提高可读性。

## 8.6 Duplicate Observed Data（复制「被监视数据」）

When ： 数据存放在 UI 类，一些 Field 函数需要访问数据。  
同一个数据可以保存在 GUI 控件，也可以保存在领域模型中。

将用户界面和处理业务逻辑分离。  
原因：  
（1）可能用不同的用户界面来表现相同的业务逻辑。如果承担相同的两种逻辑，界面可能会变得过分复杂。  
Download： 页面/通知，都表示下载进度。  
（2）分离后，维护更容易，甚至并行开发。

How ： 将数据移动到一个对象中，实现 UI 和 数据分离。  
方式 1 ： 建立一个 Observer 模式，用来同步 Field 对象和 UI 对象内的重复数据。  
UI 类是 Field 类的 Observer（观察者）。  
Field 类 是 Observal（被观察者）  
与展现无关的计算逻辑从 GUI 中分离出来。

方式 2 ： 使用事件监听器。  
在领域模型中建立一个监听器类和一个事件类。

## 8.7 Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）

![refactoring_c8_7](https://yingvickycao.github.io/img/refactoring_c8_7.jpg)

When ： 两个类都需要使用对方特征，但目前只有一条单向引用。  
开发初期，在两个类之间建立了单向连接，使得其中一个类可以引用另一个类。随着时间推移，发现被引用类需要得到其引用者以便进行某些处理。  
指针是单向的。它需要一个反向指针？

How ： 添加一个反向指针，并使修改函数能够同时更新两条连接。  
方法 1 ： 绕道而行。在被引用类中建立一个函数专门负责此行为。  
方法 2 ： 绕道不可行，则添加反向指针。  
决定哪一个类负责控制关联关系。通常让单个类来操作。

```
1 如果两者都是引用对象，其间的关联是“1对多”关系。那么由“拥有单一引用”的那一方承担“控制者”角色。
Example ： 1个客户可拥有多个订单，那么订单来控制关联关系。

2 如果某个对象是组成另一个对象的部件，那么由后者负责控制关联关系。
Example ： ViewGroup 与View，ViewGroup负责控制关联关系（add / remove/get child view）。

3 如果两者都是引用对象，它们的关联是“多对多”，那么其中任意一个对象来控制关联关系。
```

## 8.8 Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）

![refactoring_c8_8](https://yingvickycao.github.io/img/refactoring_c8_8.jpg)

When： 两个类之间有双向连接，但是其中一个类不再需要另一个类的特征。  
双向关联很有用，但是有代价：  
(1) 增加复杂度——维护双向连接，确保对象被正确创建和删除。很多车程序员不习惯使用双向关联，因此它往往成为错误之源。  
(2) 大量的双向连接很容易造成“僵尸对象”：某个对象本来已经死亡了，但是它仍然保留在系统中，因为对它的引用还没有完全清除。  
(3) 两个类之间有了依赖：对其中任一个类的的任何修改，都可能引发另一个的变化。过度耦合，可能使得任何一点小小改动都可能造成许多无法预知的后果。  
只有在真正需要双向依赖的时候，才应该使用它。

How ： 去除不必要的关联。  
在 Order 中删除持有 Customer 的引用。  
Way1 :作为参数传递  
Way2 ： 修改取值函数  
Order 如何得到它的 Customer？遍历所有 Customer，查看每个 Customer 是否包含该订单。若包含，则返回该 Customer。

## 8.9 Replace Magic Number with Symbolic Constant （以符号常量/字面常量 取代魔法数）

魔法数：拥有特殊含义，但是又不能明确表示出这种意义的数字。  
缺点：  
（1）没有意义  
（2）不同地点引用同一个逻辑数，一旦改变，需要修改全部引用点。

When ： 有一个字面值，带种含义。

How ： 创建一个常量代替字面值，根据意义命名它。  
在进行本项重构之前，应该先尝试其他方案。  
如果魔法数是类型码，使用 Replace Type Code with Class(218).  
如果魔法数是一个数组的长度，在遍历数组时，用 Array.length（）代替。

## 8.10 Encapsulate Field（封装字段）

When : 类中有一个 public 字段  
public 字段为什么不好？  
降低程序的模块化程度：一旦发生了改变，所有引用地方都要改变。

How：将它声明为 private，并提供 set 和 get 函数。
封装：数据隐藏 ——数据和行为集中在一起。

## 8.11 Encapsulate Collection（封装集合）

When ： 返回返回一个集合  
为何重构？  
（1）取值函数不该返回集合本身，它让用户修改集合内容而集合拥有者并不知道。  
（2）对用户暴露太多对象内部结构的细节。一个取值函数需要返回多个值时，它应该避免用户直接操作对象内所保存的集合，并隐藏对象内与用户无关的数据结构。  
（3）不应该为整个集合提供一个设置函数，应该为集合提供添加/移除集合元素的函数。

How ：让这个函数返回集合的只读副本（只读），并在这个类中提供添加/移除集合元素的函数  
降低集合拥有者和用户之间的耦合。

```java
// 返回一个只读读本
  public List<Course> getCourses() {
      return Collections.unmodifiableList(_courses);
  }
```

## 8.12 Replace Record with Data Class（以数据类取代记录）

When ： 面对数据记录，应该为它创建一个数据对象。  
处理数据记录？  
处理从数据库读出的记录。 或 通过一个传统 API 来与记录结构交流。

How ：
创建一个接口类，用以处理这些外来数据,以便日后将某些字段和函数搬移到这个类中。  
If 数组中的每个位置上的元素都有特定含义，这种情况下应该使用 Replace Array with Object （以对象取代数组）。

## 8.13 Replace Type Code with Class(217)（以类取代型别码）

When ： 类之中有一个数值类型码，但它并不影响类的行为。  
How ： 以一个新的类代替该数值类型码。  
类型码 / 枚举值 -> 新的类  
![refactoring_c8_13_1](https://yingvickycao.github.io/img/refactoring_c8_13_1.jpg)

类型码  
好处：省内存  
坏处：  
没有类型，因此编译器不能进行类型检验；  
代码可读性降低。

类：  
好处：  
有类型，因此编译器进行类型检验；  
工厂函数提前创建了合法的实例，它会被传递给正确的宿主对象。  
坏处：费内存

在使用本项之前，应该先考虑类型码的其他替换方案。

适合条件：类型码不会影响宿主类的行为。

```
类型码不会影响宿主类的行为?
类型码是纯数据（类型码不会在 switch 语句中引起行为变化时），才能用类取代它。
java 只能只能以整数/字符串作为 switch 语句的判断依据，不能使用任何类，因此，这种情况下不能使用以类替换类型.
即使一个类型码不会因其数值的不同而引起行为上的差异，也可以把宿主类的某些函数更适合放在类型码类中，果断移过去。
```

![refactoring_c8_13_2](https://yingvickycao.github.io/img/refactoring_c8_13_2.jpg)

## 8.14 Replace Type Code with Subclasses(223) （以子类取代型别码）

When ： 有一个不可变的类型码，它会影响类的行为  
How ： 以子类代替这个类型码

![refactoring_c8_14](https://yingvickycao.github.io/img/refactoring_c8_14.jpg)  
例子：“雇员/薪资” (Book)  
例子：“课程/课时”

类型码会影响宿主的行为，最好的办法是用“多态”来处理行为变化。  
标志：条件表达式——switch 语句或 if-then-else 结构。检查类型码值，并根据不同的值，执行不同的动作。

适用情况？  
（1）类型码影响宿主类的行为。  
（2）宿主类中出现了“只与具备特定类型之对象相关”的特性  
完成本项重构后，把这些特征推到合适的子类去，用来表示只与特性情况相关之一事实。

如何做？  
使用本重构手法来建立继承体系：以类型码的宿主类为基类，针对每种类型码建立相应的子类。

出现下面两种情况的任何一种，则不能那么做，用 Replace Type Code with State/Strategy(227)：  
（1）类型码在对象创建之后发生了变化。
（2）由于某些原因，类型码宿主类已经有了子类。

宿主类中没有出现条件表达式，用 Replace Type Code with Class(217)

## 8.15 Replace Type Code with State/Strategy(227) （以 State/Strategy 取代型别码）

When : 有一个类型码，它会影响类的行为，但无法通过继承消除它。  
How ： 以状态对象取代类型码。

![refactoring_c8_15](https://yingvickycao.github.io/img/refactoring_c8_15.jpg)

本重构使用 State 模式或 Strategy 模式.  
State 模式或 Strategy 模式 非常相似，无法选择哪一种，重构过程都是相同的。选择哪种模式，取决于更适合特定情景的模式。  
State：状态变换。Download /Media Play  
Strategy：运行时动态变换行为。Research Doc 打开为 pdf/zip。

## 8.16 Replace Subclass with Fields（以字段取代子类）

When : 各个子类的唯一差异只是在“返回常量数据”的函数身上  
How ： 修改这些函数，把它们返回到超类中的某个（新增）字段，然后删除子类。

“常量函数”（constant method）：返回一个硬编码。  
建立子类的目的，是为了增加新特性或者变化其行为。  
对于子类中只有常量函数，则果在超类中设计 一个与常量函数返回相应的字段，并去掉子类。  
![refactoring_c8_16](https://yingvickycao.github.io/img/refactoring_c8_16.jpg)

# 第 9 章 简化条件表达式

条件逻辑

## 9.1 Decompose Conditional（238）（分解条件式）

When: 有一个复杂的条件语句 （if-then -else）  
How ： 从 if 、then、else 三个段落中分别提炼出独立函数。

复杂的条件逻辑是最常导致复杂度上升的地方之一。  
大型函数自身会降低代码的可读性，而条件逻辑则会使得更加难读。

## 9.2 Consolidate Conditional Expression(240)（合并条件式）

When : 有一系列条件测试，都得到相同的结果。  
How : 合并这些测试为一个条件表达式，并提炼成一个单独函数。

提高可读性：把描述“怎么做”变成“为什么这样做”

## 9.3 Consolidate Duplicate Conditional Fragments (243)（合并重复的条件片段）

When : 在条件表达式的每个分支上都有相同的一段代码  
How ： 将这段重复代码搬移到条件表达式之外。

Way 1 ：条件分支  
Way 2 ：异常  
if 在 try +catch 块 都执行了同一段代码，将这段重读的代码移到 final 块。

## 9.4 Remove Control Flag（245）（移除控制标记）

When : 在一系列布尔表达式中，某个变量带有“控制标记(control flag)”的作用  
How ： 以 break / continue / return 语句 取代控制标记。

控制标记：大大降低条件表达式的可读性。  
注意标记变量是否会影响这段逻辑的最后结果。

## 9.5 Replace Nested Conditional with Guard Clauses （以卫语句取代嵌套条件式）

When : 函数中的条件逻辑很难看清正常的执行路径。

条件表达通常有两种形式。  
第一种形式：所有分支都属于正常。  
形式为 `if ... else if ... else if ... else`。

第二种形式：只有一个分支是正常行为，其他都是不常见的情况。  
使用卫语句“guard clauses”[Beck]:  
如果某个条件分支极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查称为卫语句。  
卫语句要么从函数返回，要么就抛出一个异常。

“单一出口原则”——“每个函数只能有一个入口和出口”。  
保持代码清晰才是最关键。如果单一出口使得函数更清楚易读，那么就使用单一出口 ，则不必这么做。

## 9.6 Replace Conditional with Polymorphism（255）（以多态取代条件式）

When :有一个条件表达式，它根据对象类型的不同而选择不同的行为。  
How : 将条件表达式的每一个分支放进一个子类的覆写函数中，然后将原始函数声明为抽象函数。

“多态”最根本好处是：当需要根据对象的不同类型而采取不同的行为时，使你不用编写明显的条件表达。  
因为多态，“类型码 switch 语句” 以及“基于类型名称的 if-then-else 语句”在面向对象程序中很少出现。

## 9.7 Introduce Null Object（引入 Null 对象）

When : 需要很多此检查这个对象是否为 null
重复的代码

How ： 将 null 换为 null 对象。

- Null Object 模式  
  空对象（null object）成为虚拟对象“missing object”  
  空对象是常量，其任何成分不会发生变化。可以用单例模式实现它。  
  当大多数客户代码都要求空对象最出相同响应时，搬移才有意义。

- Special Case 模式  
  Special Case 模式：是比 Null Object 模式更大的模式。  
  特例类，即某个类的特殊情况。  
  价值：  
  降低“错误处理”的开销。e.g., 浮点运算不会抛出异常。对 Nan 做浮点运算，结果还是 Nan。类似“空对象的访问函数通常返回一个另一个空对象”

其他特殊情况：  
可以有几种不同情况的空对象。针对不同情况建立不同的空对象类。  
“不知名顾客”：UnknownCustomer  
“没有顾客”：NoCustomer

## 9.8 Introduce Assertion（引入断言）

When : 某段代码对程序状态做出某种假设：  
当某个条件为真时，这段代码才能正常运行。使用断言，而不是注释，来明确表明这些假设。

How ： 使用断言明确表现出这种假设

断言是一个表达式，应该总是为真。如果它失败了，表示程序员犯了错。因此，断言的失败应该是 一个非受控异常（unchecked exception）。断言一定不能被系统的其他部分使用。

断言在 proc 版本上不会被执行。

断言作为 交流与调试的辅助。  
断言的价值在于：帮助程序员理解代码正确运行的必要条件。

如果程序员不犯错，断言就应该不会对系统运行造成任何影响，所以加入断言不会影响程序的行为。

不能滥用断言。不能用它检查“你认为应该为真”的条件， 只能来检查“一定必须为真”的条件。滥用断言，可能会造成难以维护的重要逻辑。  
QA self： 如果断言表示的约束条件不能满足，代码能正常运行吗？如果可以，就把断言去掉。

# 第 10 章 简化函数调用

接口

## 10.1 Rename Method（273) (重新命名函数 ）

When : 函数的名称没有表明它的用途
How ： 修改函数名称

推荐的一种编程风格：把复杂的处理拆解成许多个小函数，然后为它们起个好名字。

如何为函数起一个好名字？  
函数的名字应该准确表达它的用途。  
长度无所为。  
把函数的注释变成函数的名字。

## 10.2 Add Parameter(275) (添加参数）

When : 某个函数需要从调用端得到更多的信息。  
How ： 为此函数添加一个参数。

参数不要太长，<=5;  
在考虑该重构之前，为了不增加参数列的长度，尝试其他途径：  
1）从其他函数中获得？  
2）引入新对象参数。

## 10.3 Remove Parameter (277)（移除参数）

When : 函数本体不再需要某个参数  
How ： 将该参数移除。

无用的参数一定要移除，不要因为以后可能用到而留着，因为多一个参数阅读时就要多分一份心。  
对于多态函数，要仔细确认是否子类有用。

## 10.4 Separate Query from Modifier (279)（将查询函数和修改函数分离）

When ： 一个函数即返回对象状态值，又修改对象状态。  
理解：一个函数即有查询动作，又有修改动作。  
How ： 建立两个不同的函数，其中一个负责查询（查询函数），另一个负责修改（修改函数）。

规则：任何有返回值的函数，都不应该有看得到的副作用。  
并不绝对遵守，但总是尽量遵守。

函数有返回值，表示它有修改动作。  
当一个函数“既有返回值又有副作用”的函数，应该尝试将查询动作从修改动作中分割出来。

TODO:  
对于“看得的副作用”，有一种常见的优化办法是：将查询得到结果缓存于某个字段中，那么后续的重复查询就可以大大加快速度。虽然这种做法改变了对象的状态，但这一修改是察觉不到的。因为你无论如何查询，总是获得相同的值。

- A 一个调用了另一个函数 B，B 同时有 查询动作+修改动作 => 函数 A 调用 B1 查询函数、B2 修改函数。
- 并发问题  
  在一个多线程系统中，在同一个动作中完成检查和赋值？  
  该手法同样适用：  
  将查询动作和修改动作分开。这个“查询-修改”函数将调用各自的查询独立的查询函数和修改函数，  
  Way 1 ： 声明查询函数和修改函数为 synchronized。  
  Way 2 ：如果查询函数和修改函数没有声明为 synchronized，那么应该将它们的访问权限设为 package 或 private。  
  那么，将拥有一个安全、同步的操作，它由两个较易理解的函数组成。这两个较低层函数也可以用于其他场合。

## 10.5 Parameterize Method (283)（令函数携带参数）

When : 多个函数做了类似的工作，只是函数本体中却包含了不同值。  
How ： 建立一个函数，用参数表达不同的值。  
目的：去掉重复代码  
重点：以“将少量数值视为参数”为依据，找出重复代码。

## 10.6 Replace Parameter with Explicit Methods (285)（以明确函数取代参数）

When :一个函数，根据不同参数值而采取不同的行为  
How ：针对参数的每一个可能值，建立一个独立的函数。  
目的： 避免条件表达式，支持编译期检查，接口也更清晰。

参数值对函数行为没有太多影响，且只需要通过参数为一个字段赋值：直接使用设置函数。  
参数值对函数行为有太多影响，不需要条件判断：使用该重构。  
需要条件判断：Replace Conditional with Polymorphism（255）（以多态取代条件式）。

## 10.7 Preserve Whole Object (288)（保持对象完整）

When : 从某个对象中去取出多个值，将它们作为某次函数调用的参数。  
How ：改为传递整个对象。

目的：使得参数列更稳固；提高代码的可读性。

When 不重构？  
1）若传递的是数值，被调函数依赖的是这些数值。  
若传递的是对象，被调函数所在对象依赖的是参数对象。If 这会使你的依赖结构恶化，那么不该使用该重构。

错误的观点：被调函数只需要参数对象的其中一项数值，那么只传递那个数值会更好。  
传递一个数值和对象，代码清晰度上是等价的，性能可能有所差异。  
考量应该放在对象之间的依赖关系上。

How 重构？  
1）若调用函数使用了来自另一个对象的很多项数据，那么该函数应该被定义在那些数据所属的对象 Move Method(42))。  
2）在使用本项重构之前，可能需要重新定一个完整对象 Introduce Parameter Object(295).  
3）调用者将自己的若干数据作为参数，传递给被调用函数。若该对象有合适的取值函数，用 this 取代这些参数值，不用操心对象依赖问题。

## 10.8 Replace Parameter with Method (292）(以函数取代参数）

When ：对象调用某个函数，并将所得结果作为参数，传递给函数，而接受该参数的函数本身也能够调用前一个函数。  
How ： 让参数接受者去移除该项参数

如果函数可以通过其他途径获得某些参数值，那么不应该通过参数取得该值。  
尽可能算短参数列表的长度，因为过长的函数列表会增加阅读难度。  
预先设定的参数也要删除。

When 不能？  
1） 每一次调用动作，该参数值可能不同。  
2） 参数接收段没有参数发送端对象的引用.

## 10.9 Introduce Parameter Object (295)（引入参数对象）

When ： 某些参数总是自然地同时出现。  
这一组数据称之为数据泥团（Data Clumps）。  
How ： 以一个对象取代这些参数  
目的：缩短参数列；减少重复代码。

新类为不可变类。

## 10.10 Remove Setting Method（移除设值函数）

When ： 类中某个字段在创建时被设置，然后不再改变。  
How ： 去掉该字段的所有设值函数。  
final 字段。

## 10.11 Hide Method（隐藏你的函数）

When ： 有一个函数，没有被其他任何类用到。  
How ： 将这个函数修改为 private

1）用工具检索所有函数，指出可被隐藏出来的的函数。
2）一个类提供过多行为的接口，

## 10.12 Replace Constructor with Factory Method（以工厂方法取代构造函数）

When ： 在创建子类时，使用包含了类型码

目的： 将子类对用户隐藏起来

How ：
Type 1 : 根据类型码创建子类  
Type 2 : 根据明确函数创建子类  
类个数很少，且不再变化；超类必须知晓子类

## 10.13 Encapsulate Downcast（封装「向下转型」动作）

在强类型 OO 语言中，向下转型是不安全的。

向用户提供代码时，  
Bad : 用户承担向下转型的责任  
Good : 尽量提供准确的类型，而不是要求要。

## 10.14 Replace Error Code with Exception（以异常取代错误码）

When : 一个函数一个特定的代码，来表示某种错误情况。

目的 ： 程序中发现了错误，知道该如何处理错误。  
Java 有一种更好的错误处理方式：异常， 它将“普通程序”与“错误处理”方式。=> 代码的可读性

How ：  
决定抛出 非受控异常(unchecked)，还是受控异常(checked)。  
Way 1 ：非受控异常  
调用着负责在调用前检查必要条件。一旦程序发现了错误，终止程序。  
适合 ：程序崩溃代价很小，用户又足够宽容。

Way 2 ：受控异常  
被调用着负责检查必要条件。一旦程序发现了错误，抛出异常。调用者使用 try-catch 捕捉异常。  
适合 ：程序比较重要

## 10.15 Replace Exception with Test（以测试取代异常）

When : 一个函数可以预先检查的条件，它缺抛出了异常。  
异常可以协助避免很多复杂的错误处理逻辑，但是异常也会被滥用。  
异常只应该异常的、罕见的行为，即意料之外的错误行为，不应该成为条件检查的替代品。

How ： 用 if 判断代替异常。

# 第 2 章 重构原则

## 2.1 何为重构

### 视上下文不同，重构有两种不同的含义。

- **重构（名词）：对软件内部结构的调整，目的是在不改变软件可观察行为的前提下，提高其理解性，降低其修改成本。**
- **重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。**

重构不仅仅是整理代码，它提供了一种更高效且受控的整理技术。运用重构，对代码的整理比以前更有效。

### 重构定义的扩展：

1. 重构的目的是使得软件更容易被理解和修改。在软件内部可以做很多种修改，但必须对软件可观察的外部行为只造成很小，或甚至不造成变化。  
   与之形成对比的是性能优化。性能优化通常不会改变组件的行为（除了执行速度），只会改变其内部结构。但是两者出发点不同：性能优化往往使得代码较难理解，但是为了得到所需的性能不得不那么做。

2. 重构不会改变软件可观察行为——重构之后软件功能一如以往。

### 两顶帽子

使用重构技术开发软件时，把时间分配给两种截然不同的行为：`添加新功能（修改），以及重构`。  
添加新功能时，不应该修改既有代码，只管添加新功能。通过测试（测试正常运行），来衡量工作进度。  
重构时，不添加功能。只改进程序结构。此时，不应该添加任何测试（除非发现有先前遗漏的东西），只有在绝对必要（用以处理接口变化）时才修改测试。

**软件开发过程中，经常变化帽子，但无论何时只能戴有一顶帽子。**  
=> 重构的两种思维：在软件开发的过程中，修改和重构经常会交叉。因为二者是两种不同思维方式，为避免产生思维混乱，最好将二者独立开来：同一时间只做同一件事，要么编程，不做重构；要么重构，不做编程.

## 2.2 为何重构

重构是个工具，它可以并且用于以下几个目的：

### 重构改进软件设计 => 改善设计

随着时间增长，原先优雅的软件将逐渐失去自己的结构，程序员越来越难通过阅读源码而理解原理的设计。  
代码的流失是累计性的。越难看出代码所代表的设计意图，就越难保护其中设计，于是该设计就腐败得越快。

1. 经常性的重构可以帮助代码维持自己该有的形态。
2. 改进设计的一种重要方向是：消除重复代码，目的是方便未来的修改，减少出错的可能性。

- Chaoswx 评：
  编程考虑的是实现功能，为此常常可能牺牲结构、性能、扩展性，着眼的是局部等，这都是难免的。  
  重构考虑的是重新梳理软件的功能之间的逻辑和功能内部的实现，着重的是系统，所以更多的是考虑理解性、扩展性、稳定性等。  
  如果二者同时进行的话，可能就会产生考虑过多，导致无法编码或编码艰难。  
  本质上，编码和重构是存在矛盾的，结合我以往的经历来看，同时做两件相互冲突的事，就会丧失思考力，因为你考虑的东西太多，结果反而不知如何是好了！

- Chaoswx 总评：
  把软件比作人体，重构就是锻炼身体，可以排除体内的负能量（垃圾、毒素等），也可以提升自身的身体素质，增加器官的活性，提升身体的抵抗力； 你可以去健身房，也可以抽个业余时间；  
  锻炼的目的一般来说有两个：  
  1.改变个人的精神状态，使得身体处于积极状态；  
  2.为了追求身体之美，像古希腊人一样为了追求身体之美而锻炼；

### 重构使软件更容易理解 => 提升可读性

- 编码模式的核心：“准确说出我想要的” => 人 -> 计算机/其他程序员。其中，其他程序员是最重要的读者。
- 重构使得代码更易读。
- 利用重构来协助理解不熟悉的代码。  
   当看到不熟悉的过程，试着去理解其用途。使用重构来真正修改代码，让它更好地放映出我的理解，然后重新执行，看它是否仍然正常运行，以此检验我的理解是否正确。  
   一开始的重构时停留在细枝末节上，随着代码越来越简洁，能发现自己看到一些看不到的设计层面的东西。重构能把我们带到更高的理解层次上。

### 重构帮助找到 bug => 减少错误

- 对代码的理解，可以帮助找到 bug。  
  如果对代码进行重构，可以深入理解代码的行为，并恰好地把新的理解反馈回去。搞清楚程序结构的同时，清楚自己所做的一些假设，这样很容易把 bug 找出来。
- 重构能帮助我们更有效地写出强健的代码。

### 重构提高编程速度

- 前面的一切都归结于这最后一点：重构帮助快速地开发程序。 以上几个原则都是提高质量，从而提高开发速度。
- 良好的设计是快速开发的根本。重构可以更快地开发软件，因为它阻止系统腐败变质，它甚至还可以提高设计质量。

## 2.3 何时重构

何时重构？  
不要专门播出时间进行重构。
重构本来就不需要专门播出时间去做。重构应该随时随地地进行。
不应该为重构而重构，之所以重构，是因为特别想做别的什么事，而重构帮助把这些事情做好。

#### 三次法则：事不过三，三则重构。

准则：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次在做类似的是，你就应该重构。

#### 添加功能时重构 => 增

- 最常见的重构时机是给软件添加新特性的时候。  
  此时，重构的直接原因，往往是为了帮助我自己理解需要修改的代码。 一方面是为了下次能更好的理解这段代码模块，但最重要的原因是：如果在前进过程中 把代码结构理清，我就可以从中理解更多东西。
- 重构的另一个原动力：代码的设计无法帮助我轻松添加我所需要的特性，此时使用重构弥补它。重构是一个快速流畅的过程，一旦完成重构，新特性的添加就会更快速、更流畅。

#### 修补错误时重构 => 改

调试过程中运用重构，多半是为了让代码更具可读性。  
收到一份错误报告时，先重构来处理代码，常常帮助找出 bug。

#### 复审代码时重构 => 查

1. 代码复查的好处：

- 有助于开发团队中传播知识。
- 有助于比较有经验的开发者把知识传递给比较欠缺经验的人
- 帮助更多人理解大型软件系统中的更多部分。
- 对编写清晰代很重要。
- 让更多人提供有用的建议。

2. 重构可以帮助复审别人的代码。  
   开始重构前可以先阅读代码，得到一定程度的理解，并提出建议。一旦想到一些点子，我会考虑是否可以通过重构立刻轻松地实现它们。如果可以，就动手。这样做过几次后，可以把代码看得更清楚，提出更多恰当的建议。

3. 重构可以帮助代码复审工作得到更具体的结果。不仅获得建议，而且其中许多建议能够立即实现。最终从实践中得到比以往多得多的成就感。

4. 作者会和某个团队进行设计复审，而和单个复审者进行代码复审。

   较小规模代码复审时，复审团队必保持精炼。  
   推荐的一个做法：:  
   最好是一个复审者搭配一个原作者，共同处理这些代码。复审者提出修改建议，然后两人共同判断这些修改是否能够通过重构轻松实现。果真能够如此，就一起着手修改。

   较大规模的设计复审时，在一个较大团队内保留多种观点通常会更好一些。 此时直接展示代码不是最佳的办法。  
   推荐的一个做法：喜欢 UML 示意图展示设计，并以 CRC 卡展示软件情节。

   [CRC 卡](http://www.cnblogs.com/gnuhpc/archive/2012/01/13/2321492.html)

5. 极限编程[Beck, XP]中的”结对编程"形式，把代码复审的积极性发挥到了极致：在开发过程中随时进行的代码复审工作，重构也被包含在开发过程中了。

6. **为什么重构有运用 —— Kent Beck**

   程序有两面性:"今天可以为你做什么" 和 “明天可以为你做什么”。  
    如果纯最只为今天工作，明天我将无法完全工作。
   是什么让程序那一相与？：

- 难以阅读的程序，难以修改；
- 逻辑重复的程序，难以修改；
- 添加新行为需要修改已有代码的程序，难以修改。
- 带复杂条件逻辑的程序，难以修改。

因此希望程序：

- 容易阅读
- 所有逻辑都只在唯一地点指定
- 新的改动不会危机现有行为
- 尽可能简单表达条件逻辑

重构是这样的一个过程：它在一个目前可运行的程序上进行，在不改变程序行为的前提下使其具备上述美好性质，使我们能够保持高速开发，从而增加程序的价值。

## 2.4 怎么对经理说

- 如果经理只对质量感兴趣，那么问题就可以集中到“质量“上面。  
  此时，`在复审过程中使用重构是一个不错的办法。 大量研究结果显示，技术复审是减少错误、提高开发质量的一条重要途径。`  
  找一本关于复审、审查和软件开发程序的书看看， 找出最新引证，应该可以让大多数经理认识复审的价值。然后可以把重构当作”将复审意见引入代码内“的方法来使用，这容易。

- 如果经理是”进度驱动“，而非他自己说的”质量驱动“：  
  这种情况：不要告诉经理。  
  重构是理解 软件的最快方式。 受进度驱动的经理要我可能快速完事，至于怎么完成，那就是我的事。我认为最快的方式就是重构，所以我就重构。  
  => 好主意

### 间接层和重构 —— Kent Beck

**间接层是一柄双刃剑。**

间接层有它的价值。  
在重构中引入间接层的某些价值：

- 允许逻辑共享
- 分开解释意图和实现
- 隔离变化
- 封装条件逻辑：多态消息，能将条件逻辑转化为消息形式，  
  -> 降低代码的重复，增加清晰度并提供弹性。  
  找出不值得的中间层，并将它拿掉。

## 2.5 重构的难题

=> 知道技术的优势和劣势。只要劣势，说明你懂了。只要优势，说明你刚刚入门。

### 数据库

重构经常出问题的一个领域是数据库。

数据库结构难以修改的原因：

1. 很多商用程序都与它们背后的数据库结构紧密耦合在一起。
2. 数据迁移
   即使将系统分层，将数据结构和对象模型间的依赖降低至最低，但是数据结构的改变还是让你不得不迁移所有数据。

非对象数据库的解决办法之一：在对象模型和数据库模型之间插入一个分割层，这样隔离各个模型各自的变化。升级某一个模型时，无需同时升级一个分割层，这样可以隔离两个模型各自的变化。  
一开始不需要插入分隔层。在发现对象不稳定时再产生它。

对象数据库：数据迁移要并非自动进行，而是自行转移工作。转移字段要格外小心。

### 修改接口

对接口要特别谨慎：

1. 公开接口(public interface)  
   如果某个函数的所有调用者都是在你的控制之下，可以修改。
2. 已发布接口（published interface）  
   如果接口是个已发布接口（published interface）——比公开接口(public interface)更进一步。  
   重构改变已发布接口时，保留旧接口：让旧旧接口调用新接口。并将旧接口标记 depressed。千万不要复制函数实现。
3. 不要发布接口  
   发布接口很有用，但是也有代价。除非真有必要，不要发布接口。  
   过度强调代码所有权的团队常常会犯这种错误。  
   **不要过早发布接口。请修改你的代码所有权策略，使重构更顺畅。**
4. Java 中有一个特别的接口修改：在 throws 子句中增加一个异常。

### 难以通过重构手法完成的设计改动

将某个设计重构成另一个设计的难度很大。  
e.g., 很难利用重构将不考虑安全性需求时构建的系统重构成一个具备良好安全性系统。  
e.g., App navigator

### 何时不该重构

1. 现有代码过于混乱，重构不如重写简单。
2. 重写而非重构的一个讯号：现有根本(大部分情况下)不能正常工作。  
   可能这是试着做一些测试，发现代码中满是错误，根本无法稳定工作。记住：重构之前，代码必须起码能够在大部分情况下正常运作。  
    一个折衷的办法：将“大块头”软件重构为封装良好的小型组件。然后逐一对组件做出“重构或重建”的决定。

3. 项目已近最后期限，应该避免重构。  
   因为项目临近交付，已经没有时间了。  
   经验显示：重构能提高生产力。如果最后你没有足够时间重构，重构就表示其实早该进行重构。

## 2.6 重构与设计

1. 一种观点：重构肩负一项特殊使命：它和设计彼此互补。
2. 另外一种观点： 极限编程【Beck，XP】的支持者极力提倡：重构可以取代预先设计。

只用重构也能收到效果，但这并不是最有效的途径。极限编程的爱好者们也会进行预先设计。  
做预先设计，不一定找出正确的解决方案，得到一个足够合理的解决方案就够了。 以后如果最佳解决方法和原始设计不同时，通过重构，让日后的设计修改成本不再高昂，软件更易维护。 因此，软件设计向简化前进了一步。  
设计可以带来更简单的设计，同时又不损失灵活性，降低设计过程的难度，减轻了设计压力。

### 劳而无获 —— Ron Jeffries

问题：综合薪资系统的支付过程太慢了，而它已经拖累了测试程序。  
原因：系统用一半的时间来创建日期实例  
解决：创建一个固定不变的“空日期区间区间”对象。然后用工厂函数始终返回该对象，而不是每次都创建新对象。

教训：哪怕你完全了解系统，也请实际度量它的性能，不要臆测。臆测会让你学到一些东西，但是十有八九你是错的。  
问题 -> 原因 -> 解决 3

## 2.7 重构与性能

**重构不一定提升软件性能，但可以使性能提升更容易。**

除了对性能有严格要求的实时系统，其他任何情况下“编写快速软件”的秘密：首先编写可调试的软件，然后调整它以求获得足够速度。

三种编写快读软件的方法：

1. 其中最严格的时间预算法。

- 通常只用于性能要求极高（也就是高度重视性能）的实时系统。例如：心率调节器。  
  分解设计时，要做好预算，给每个组件预先分配一定资源——包括时间和执行轨迹。每个组件绝对不能超出自己的预算，就算拥有组件之间调度预配时间的机制也不行。

- 对于一般软件来说，则不必如此追求高性能。

2. 持续关注法

- 这种做法要求程序员在做任何修改时，必须保证程序的高性能。
- 一般很难实现，因为任何一次的修改如果是为了性能提升的话，通常都会使程序难以维护。
- 如果以此换来程序的性能提升倒也值得，但是大部分情况下并非如此；性能改善往往着于一角，局部的性能提升了，但是整体的性能却是无法保证。

  对大多数程序进行分析，发现它把大半时间都耗费在一小半代码身上。如果不同一视同仁地优化所有代码，90%的工作都是白费的，因为被优化的代码大部分很少被执行。

  就 Chaoswx 开发的经历来说，部分性能的提升在很大程度上会提升系统性能，当然前提是软件编码很糟糕，有很大的优化空间。

3. 根据二八原则，影响程序 90%性能的往往是 20%的代码

- 编写良好的程序，不对性能做太多关注，直到进入开发后期 ——性能优化阶段。
- 在性能优化阶段，集中精力测试。
  使用度量工作，定位性能热点的代码，然后集中关注这些性能热点。并使用持续关注中的优化手法来优化。  
  和重构一样，小幅度修改。每走一步，都需要编译、测试、再次度量。如果没有提高性能，应该撤销此次修改。  
  继续“发现热点、去除热点”的过程，直至获得满意的性能为止。
  **McConnel【McConnel】能提供这项技术的更多信息。**

构造良好的程序，从两方面帮助这一优化形式：

- 因为更快添加功能，所以，它让你比较有充裕的时间进行进行性能调整。
- 因为在进行系统分析时有较细的粒度，性能调整更容易。

**重构可以帮助写出更快的软件。短期看来，重构的确可能使变慢，但它使优化阶段的软件性能调整更容易，最终还会得到更好的效果。**

## 2.8 重构起源何处

重构 Refactoring

著名的 Gof【Gang of Four】之一 Ralph Johnson，最大兴趣之一是开发软件框架，揭示重构对于灵活高效框架的开发帮助。

### 优化一个薪资系统

Step 1 : 优化“巨大字符串”  
优化前：薪资运算需要 1000 小时  
问题：创建大量 12 000 字节大小的“巨大字符串”  
问题：800 字节、500 字节等微小字符串  
解决：缓存字符串 + 写入文件流：避免产生字符串。  
优化后：原本需要 1000 小时，实际运行花 40 小时  
-> 一个月后，18 小时  
-> 正式投入 12 小时  
-> 经过一年的运行和改善，9 小时。  
-> 以多线程方式运行在多处理计算上，2 小时。

教训：  
使用工具来实际操作中度量系统性能，而非只靠猜测，否则需要很长时间才能试出真正的解法。真实的度量指出一个完全不同的方向，并大大加快了优化进度。

## Reference

- [Chaoswx - 重构 改善既有代码的设计——重构原则](http://blog.csdn.net/zhongshujunqia/article/details/52469841)
- [Sheh 伟伟 - 《重构：改善代码的既有设计》读书笔记](https://www.cnblogs.com/davidsheh/p/5239745.html)

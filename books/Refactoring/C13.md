# 第 13 章 重构，复用与现实

重构技术支持软件面向对象软件的变化。  
关于重构的认识都适用于更普遍意义的问题，例如软件复用、产品开发、平台选择等。 但是本章关注的焦点，主要是实际的现实世界的问题，以及解决方案。

## 13.1 现实的检验

软件开发的主要成本是后期维护（修改和调整），而不是最初版本。  
技术的发展超前于实践。  
常识性原因影响了开发者，造成了即使了解重构的好处，也不愿意重构程序。

## 13.2 为什么开发者不原因重构他们的程序？

重构的多好处？  
通过重新组织软件结构，重构使得设计思路更详尽明确。  
重构被用于开发框架、抽取可复用组件、使软件结构更清晰、使新功能的增加更容易。  
重构可以帮助充分利用以前的投资，减少重复劳动，使得程序更简洁有力。

即使重构有那么多好处，为什么还不愿意重复程序？  
不知道如何重构。 => 如何重构，在哪里重构  
重构以求长期期利益，短期内可能看不到效果。=> 重构以求短期利益  
代码重构是一项额外工作，老板付钱给你，主要是让你编写新功能。 => 降低重构带来的开销  
重构可能破坏现有程序。 => 安全地进行重构

### 如何重构，在哪里重构

如何重构？

重构手法，分为低级重构手法和高级重构手法。原因是从自动化支持和安全两方面考虑。  
低级重构手法处理简单的情况。  
高级重构手法由低级重构手法定义出来，用来处理复杂的情况。

- 对既有程序，使用哪些重构？  
  取决于目标。一个常见的重构原因，是调整程序结构以使（短期内）添加新功能更容易。  
  好的程序结构性质量和特征能够成为可扩展性和可复用性提供支持。  
  对于设计模式的很多研究，都集良好编程风格以及程序各部分之间有用的交互模式，这些都可以用映射为结构特征和重构手法。例如：Template Method 模式 -> 超类重构手法。

  自动工具可用于识别程序中的结构缺陷、结构相似性，这些地方都应该考虑成为重构的对象。  
  自动工具可以分析程序结构，建议可能改进程序结构的重构手法。  
  自动工具仅仅只是在程序结构分析上提出建议，是否修改，取决于程序员的决定。  
  自动工具，例子 IDEA Lint 工具。

- 如何重构，在哪里重构，经验是无可替代的。  
  重构过程中，程序员对重构的理解也会逐渐加深。

### 重构以求短期利益

- 重构的短期利益：  
  代码复用：减少代码总量；  
  程序更容易查找错误；  
  程序更容易维护：修改更容易，如果在测试阶段发现共同的代码有错误，只需在一个地方修改。

- 重构的长期利益  
  程序更容易扩展。

  重构可以带来短期利益，让软件更易修改、更易维护。重构只是一种手段，不是目的。它是“程序员或程序开发团队如果开发并维护自己的软件”这一更宽广场景的一部分。

### 降低重构带来的开销

Q ： “重构是一种需要开销的活动。我付钱是为了让程序员写出新的、能带来收益的软件功能。” ？  
A：  
已有的工具和技术，使得重构快速。  
重构虽然需要开销，但它能在程序开发的其他阶段降低精力和时间开销，从而补偿它的开销。
当重构称为软件开发规则的一部分，会觉得它是必不可少的，不再觉得它费事。  
自动重构工具。  
重构成为日常，就不会觉得花高代价了。

### 安全地进行重构

- 什么是“安全重构”？  
  “安全重构”是不会对程序造成破坏的重构。  
  由于重构的意图就是在不改变程序行为的前提下修改程序结构，所以，重构后的程序行为应该与重构前完全相同。  
  => 重构前后，用户感觉不出来变化，程序行为一样。

- 如何进行安全重构？  
  (1)【编码风格】相信自己的编码功力。  
  => 无论编码者自身代码代码功底有多牛 ，人总会犯错。所以，要学点专业的重构知识很重要，然后小心、小心，再小心。  
  (2)【编译器】编译器能捕捉遗留的错误。  
  (3)【测试】测试套件能捕捉自己和编码器遗留的错误。  
  (4)【代码复审】代码复审作为前三个的补充，能捕捉自己和编码器和测试套件都遗留的错误。

编码风格、测试套件、代码复审、严守纪律的编码风格都很有价值，但是所有这些方法还是有局限性：  
(1)所有程序员都可能犯错。  
(2)有一些微妙和不那么微妙的错误，编译器无法捕捉，特别是那些与继承相关的作用域错误。  
=> 藏得很深的 bug，只有当某些条件成立才会出现。  
(3)测试套件无法覆盖所有可能情况。 => 多测试。保证绝大多数 bug 都能发现。  
(4)和程序员一样，代码复审员也可能犯错。而且复审人员可能因为忙于自己的主要工作，无法彻底检查别人的代码。  
=> 这种情况经常出现，被邀请审查代码，由于很忙，匆匆看过，造成潜在 bug 没有检查出来。  
=> 多邀请几人人，总有人会有空  
=> 如果 reviewed code 很重要，先忙完最重要的事情，然后再去 review。  
=> 下午比较累，错误不一定看得出来。 ->Pending review, if possible，next Monday review。

- 作者在研究工作中使用的另一种方法：用于检查某项重构是否可以安全地施加于程序身上。如果可以，就重构之。这避免大量可能因为人为错误而引入的 bug。  
   (1)重构工具的一部分是程序分析器，用来分析程序结构。  
   => 前面已经提到了。IDEA Lint  
   对重构安全性进行的检查（尤其是对于数量占绝对优势的底层重构往往是轻而易举的）。为了保证较高层重构、较复杂重构的安全性，以低层重构来定义它们。只要保证复杂重构的每一个步骤是安全的，就可以确定整个复杂重构也是安全。  
   => 前面提到了 高层重构 = SUM 低层重构。 如果高层重构感觉没把握，尝试先进行一些低层重构：修改函数名、去掉没用的形参、修改访问权限等，只要能提高程序可读性的重构，都可以重构。有时候多个低层重构步骤后，程序结构比较清晰了就能知道怎么高级重构。  
   (2)在某些十分罕见的情况下，在工具无法确认时，仍然可以安全实行重构。此时，工具会选择较安全地方式：禁止重构。  
   重构工具可以标记出这种可能不安全地引用关系，并向用户提出警告。用户可以先把这段代码放在一旁。一但能够确定引用点永远不会被执行到，把这段多余代码移除，而后进行重构。这个工具让用户知道存在这么一个隐藏的引用关系，而不是盲目地进行修改。  
   => 暂时还没有碰到这种场景。假如这段代码没有彻底读懂，我选择暂时不重构，以后再说。

  (2) 所有的安全性检查都可以在重构工具中实现。  
   => IDEA lint 几乎能实现所有检查。但是也碰到不靠谱的重构：修改一个函数名，结果工具把整个 project 中所有类的同名函数，包括注释中的形同名称，也修改。最后只能通过 diff tool 还原。  
   => 确认重构前，先看看影响范围，如果范围不正确，只能手动修改逐个修改。

- 编译、测试和代码复审可以指出许多错误，但也会遗留一些错误，重构工具则帮助抓住遗留错误。  
  有些重构不但会把代码清扫干净，而且还会程序运行更快。然而提升某个程序的速度，可能会在另一个地方造成性能瓶颈。  
  有些重构可可能略微降低系统整体性能。  
  一般来说，重构对性能影响是微不足道的。  
  => 有些重构手法，一个类拆分成几个类。虽然文件个数增加了，对绝大多数程序来说，当前硬件来说，影响几乎可以不计较。而且重构后，代码可读性提高了，更容易找到提升性能的修改点。
- "安全性措施"用来保证重构不会向程序引入新错误。这些措施并不能检查或修复重构前存在的错误。 但重构可以使得更容易找到并修复这些错误。

## 13.3 论现实的检验

对某些项目，以下问题也需要关心:

- 如果代码由多位程序员共同拥有，怎么办？  
  一方面，许多变更管理机制可以解决这个问题。  
  另一方面，如果软件设计良好，又经过重构，子系统之间就会有效分离，于是许多重构手法都会影响代码的一小部分。

- 如果代码库中有多个分支版本，怎们办？  
  如果若重构和每一个分支相关时，在重构前先对所有分支进行安全测试。  
  如果重构可能只与某些分支相关时，检查过程和重构过程就简单多了。  
  如果同时管理多个分支变化，通常需要使用许多传统的版本管理技术。 => Git + 比较工具  
  如果将多个分支并入一个新的代码库中，重构也会有所帮助，因为它可能简化合并工作。

- 实际上，有时候较复杂重构需要时间很长，几周，几个月，甚至是半年。 这时候重构后 refactor_branch -> develop_branch，由于时间过长，版本更新太多，代码差异非常大，连文件也对应不起来，根本无法 review。  
   这情况怎么办？  
  => 经常 develop_branch -> refactor_branch, 始终保持重构是最新结构的代码。  
  => 当 develop_branch 代码结构要巨大变更时，快速重构出一个最基本的框架，经过严格测试并保证正确后，refactor_branch => develop_branch，这样以后重构 code 和 develop_branch code 始终保持大致框架一致，方便合入代码以及 review。  
  => 即使代码差异非常大也没有关系，merged 代码时，和目标 branch 的代码最熟悉人员一起，结合比较工具，手动 merged。 这种方法，操作起来比较难。实际上，写过的代码很容易忘记，同时由于命名不好等原因很容易就迷失在代码中。

## 13.4 重构的资源和参考资料

《程序设计的模式语言》

## 13.5 从重构联想到软件复用和技术传播

前面提高的现实世界问题，不仅仅存在于重构中。它们广泛存在于软件的演化和复用中：重构、软件复用性、平台、框架、模式、遗留系统（往往涉及非面向对象软件）的发展相关问题。

- 复用方法的现实问题，和重构的相关问题很类似：  
  (1)技术人员可能不知道“该复用什么” 或 “如何复用”。
  => 套用老师一句话：通过学习专业知识，把实践上升到理论的角度。  
  (2)技术人员可能对于采用复用方法缺乏动力，除非他们能够获得短期利益。  
  (3)如果要成功适应复用方法，开销、学习曲线和探索成本都必须考虑。  
   => 多读美国人写的技术书:可读性比较强。关键是研究成果很成熟，有很多实践和理论支持。 讨论、问题反馈和疑问求助，作者比较匠心，很给力。  
  (4)采用复用方法不该引起项目混乱。新的实现应该与现有系统协同工作，或至少向下兼容现有系统。

Geoffery Moore 把技术的接纳过程描述为一条钟型曲线：
前段包括先行者（源码作者）和早期接受者（小白鼠）；
中部急剧增加的人群包括早期消费群体和晚期消费群体（软件开发者，尤其是项目经理）；
后段包括行动缓慢者（技术已经快落花了，才开始使用）。

一个思想或产品如果要成功，必须得到早期消费者和晚期消费者的广泛支持。  
先行者和早期接受者感兴趣的是新技术、“范式转移和突破性思想”的愿景。  
消费群体和晚期消费群体则主要关注成熟度、成本、支持，以及这种思想或新产品是否被与他们有着相似需求的其他人成功套用。  
把打动并说服软件开发者，所需的方式和打动并说服研究者是完全不同的。 软件研究者通常是先行者。软件开发者（尤其是软件经理）则往往是早期或晚期消费者。

提倡复用及运行其必要平台，得冒一点风险。主管人员人员精心制定策略、在中经理层组织领导会议、与项目开发组协商、通过研讨会和出版物向广大研究人员和开发人员宣扬这些技术的好处。在整个过程中，很重要的几件事是：**对员工进行培训、尽量获得短期利益、减少开销、安全引入新技术。**  
=> 管理层提供支持。技术再好但不允许使用，然并卵。 害怕代码变导致有问题的管理层，只能先顺服。

这些原则不仅可应用于重构和软件复用，同时也是技术传播时的常见问题。如果你正试图说服别人重构（或采用其他技术或实践），请注意保证自己随时关注这些问题，这样才能深入人心。技术的传播是很困难的，但不是做不到。  
=> android 官网做的非常好。技术文档很全。开发者反馈的问题很快能修复。同时，每年 I/O 会议和官网、公众号 都能及时传播新东西。

### 13.6 小结

本章主要解决可能会有的关于重构的一些问题，并尝试了解重构的一些现实问题，这些问题亦存在于更广泛的领域中，例如软件演化和复用。

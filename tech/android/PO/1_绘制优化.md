# 绘制优化


# 1 卡顿的场景

卡顿的场景，分成4类： UI 绘制、应用启动、页面跳转、事件响应。



<div align="left"> <img src="https://yingvickycao.github.io/img/android/po/绘制优化_卡顿场景.svg" width = 50%/>
<div>


# 2 卡顿的原因
上面4 种场景的根本原因可以分为2大类。
<div align="left"> <img src="https://yingvickycao.github.io/img/android/po/绘制优化_卡顿原因.svg" width = 50%/>
<div>

上面的原因，会产生（1）和（2），从而导致卡顿：    
（1）绘制任务太重了，绘制一侦内容耗时太长。  
（2）主线程太忙了，导致VSync信号来时还没有准备好数据导致丢帧。  
卡顿的本质是VSync信号到来时，不能及时处理绘制事件导致。

# 3 Rule
- Do not block the [UI Thread](../process_and_thread/UI_Thread.md) by using background work：  
disk I/O /  DB Access / network calls / long-running operations    
- Do not access the Android UI toolkit from outside the UI thread

    如何切换到主线程？  
    Activity.runOnUiThread(Runnable)   
    EventBus ：小心  
    Handle  
    RxJava：  
        subsribeOn - 切换之前的线程      
        observeOn - 切换之后的线程。   
        observeOn之后再次调用subsribeOn不能切换线程    
    View.post(Runable)  
    View.postDelayed(Runbable)    
    AsyncTask(Depressed)  

# 4 UI 线程
为了解决 2-(2)的问题。

所有的绘制工作由主线程（UI线程）来负责。
主线程的关键职责是    
1)处理用户交互     
2)在屏幕上绘制像素     
3)加载显示相关的数据。      

主线程应该做什么？  
1）UI 生命周期控制  
2) 系统事件处理  
3) 消息处理  
4) 界面布局  
5) 页面刷新  
除了这些，不能把其他处理放在主线程中，特别是复杂的数据计算和网络请求。  


# 5 性能分析工具
做性能优化时，最直接有效的方式是，尽可能地复现存在性能问题的场景，并监控此过程中程序的执行流程。分析程序中函数的调用关系和执行时间，找出性能瓶颈。 

卡顿能监控吗？  

# 5.1 Profile GPU Rendering or Profile HWUI rendering
用处：发现渲染有问题的页面。
还需要使用另一个耗时工具和代码来具体分析，找出性能的瓶颈，并进行优化。  

# 5.2 检测界面卡顿 "Profiler" -> CPU -> System Trace
https://developer.android.google.cn/studio/profile/jank-detection?hl=zh-cn

`.trace`

# 6 布局优化工具


# 7 Android 系统显示原理          
Android 的显示过程可以简单概括为:   
Android 应用程序把经过测量、布局、绘制后的surface 缓存数据，通过 SurfaceFlinger 把数据渲染到显示屏幕上，通过 Android 的刷新机制 来刷新数据。也就是说应用层负责绘制，系统层负责渲染，通过进程间通信把应用层需要 绘制的数据传递到系统层服务，系统层服务通过刷新机制把数据更新到屏幕。

Android 的图形显示系统采用的是 Client/Server 架构。  
SurfaceFlinger(Server)由 C++代码编写。Client 端代码分为两部分，一 部分是由 Java 提供给应用使用的 API，另一部分则是由 C++写成的底层具体实现。

## 绘制原理

###  应用层
一个UI 界面是由很多view组成的树结构。   
如何完整地显示所有数据？通过递归，对每一个view进行一次绘制工作。  


图：页面构成结构      
![viewgroup_2x](https://yingvickycao.github.io/img/android/widget/viewgroup_2x.png)

图：View 绘制流程   
  ![view_draw_process](https://yingvickycao.github.io/img/android/widget/view_draw_process.png)


每一个view绘制由三个核心步骤：Measure、Layout、Draw。通过 Measure 和 Layout 来 确定当前需要绘制的 View 所在的大小和位置，通过绘制(Draw)到 surface.      
ViewRootImp 类的 performTraversals()方法，通过这个方法可以 看出 Measure 和 Layout 都是递归来获取 View 的大小和位置，并且以深度作为优先级。=> 层级越深，元素越多，耗时也就越长。  
(1) Measure : 用深度优先原则递归得到所有视图(View)的宽、高。  
(2) Layout ： 用深度优先原则递归得到所有视图(View)的位置。    
(3) Draw ： 支持两种绘制方式：软件绘制(CPU)和硬件加速(GPU)。  

硬件加速的优点： 
UI 的显示和绘制的效率较高。  

硬件加速的缺点：  
耗电:GPU 的功耗比 CPU 高。  
兼容问题:某些接口和函数不支持硬件加速。  
内存大:使用 OpenGL 的接口至少需要 8MB 内存。
   
### 系统层
把需要显示的数据渲染到屏幕上，是通过系统级进程中的 SurfaceFlinger 服务来实现的。 
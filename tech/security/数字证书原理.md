# 数字证书原理

这篇博客非常优秀，所以，基本上大部分内容都在。

# 1 一个加密通信过程的演化

## 1.1 第一回合：

```
“客户”->“服务器”：你好“服务器”->“客户”：你好，我是服务器

“客户”->“服务器”：？？？？
```

在网络上传输信息时，他人,e.g.,客户，可以冒充服务器。

```
// 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”
“客户”->“黑客”：你好
“黑客”->“客户”：你好，我是服务器
```

如何确定信息是由“服务器”发过来的呢？  
解决方法：  
因为只有服务器有私钥，所以如果只要能够确认对方有私钥，那么对方就是“服务器”。  
因此通信过程被改进成 1.2

## 1.2 第二回合：

```
“客户”->“服务器”：你好
“服务器”->“客户”：你好，我是服务器
“客户”->“服务器”：向我证明你就是服务器
“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]
```

如何向“客户”证明自己是“服务器”？：
“服务器”把一个字符串用自己的私钥加密，把明文和加密后的密文一起发给“客户”。
“客户”收到信息后，用它自己持有的公钥解密密文，和明文进行对比，如果一致，说明信息的确是由服务器发过来的。

假设“黑客”想冒充“服务器”：

```
“黑客”->“客户”：你好，我是服务器
“客户”->“黑客”：向我证明你就是服务器

//这里黑客无法冒充，因为他不知道私钥，无法用私钥加密某个字符串后发送给客户去验证。
“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[？？？|RSA]
“客户”->“黑客”：？？？？
```

PS:  
{} 表示 RSA 加密后的内容，  
[ | ]表示用什么密钥和算法进行加密  
{你好，我是服务器}[私钥|RSA] 就表示用私钥对“你好，我是服务器”进行加密后的结果。

由于“黑客”没有“服务器”的私钥，因此它发送过去的内容，“客户”是无法通过服务器的公钥解密的，因此可以认定对方是个冒牌货！

## 1.3 第三回合

“客户”就可以确认“服务器”的身份了，可以放心和“服务器”进行通信，但是这里有一个问题，通信的内容在网络上还是无法保密。

```
“客户”->“服务器”：你好
“服务器”->“客户”：你好，我是服务器
“客户”->“服务器”：向我证明你就是服务器
“服务器”->“客户”：你好，我是服务器 [私钥|RSA]
“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]
“服务器”->“客户”：{你的余额是100元}[私钥|RSA]     // 问题：只要拥有公钥，就可以看到该信息
```

{你的余额是 100 元}[私钥]，这个是`“服务器”->“客户”：你好，我是服务器:[私钥|RSA]`:服务器用私钥加密，客户用公钥解密。因为公钥是公开发布的，只要是拥有公钥的人，就可以看到这条信息。

如何解决呢？  
引入对称加密。See `1.4`

## 1.4 第三回合

```
“客户”->“服务器”：你好
“服务器”->“客户”：你好，我是服务器
“客户”->“服务器”：向我证明你就是服务器
“服务器”->“客户”：你好，我是服务器 {你好，我是服务器}[私钥|RSA]

“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]
“服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]
“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]
“服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]
```

“客户”在确认了“服务器”的身份后，“客户”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥一起用公钥加密后发送给“服务器”。由于对称加密算法和密钥是用公钥加密的，就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无从知道对称加密算法和密钥的内容。  
由于是用公钥加密的，只有私钥能够解密，这样就可以保证只有服务器可以知道对称加密算法和密钥，而其它人不可能知道(这个对称加密算法和密钥是“客户”自己选择的，所以“客户”自己当然知道如何解密加密)。这样“服务器”和“客户”就可以用对称加密算法和密钥来加密通信的内容了。

总结，RSA 加密算法在通信过程中所起到的主要作用：  
(1)因为私钥只有“服务器”拥有，因此“客户”可以通过判断对方是否有私钥来判断对方是否是“服务器”。  
(2)客户端通过 RSA，安全的和服务器商量好一个对称加密算法和密钥来保证后面通信过程内容的安全。  
以上过程解释了：为什么不用 RSA 去加密通信过程，而是要再确定一个对称加密算法来保证通信过程的安全，  
“客户”就可以确认“服务器”的身份，并且双方的通信内容可以进行加密，其他人就算截获了通信内容，也无法解密。

---

遗留问题：“服务器”要对外发布公钥，那“服务器”如何把公钥发送给“客户”呢？  
我们第一反应可能会想到以下的两个方法：  
a)把公钥放到互联网的某个地方的一个下载地址，事先给“客户”去下载。  
评价：客户”无法确定这个下载地址是“服务器”发布的，还是他人伪造的。  
b)每次和“客户”开始通信时，“服务器”把公钥发给“客户”。  
评价：因为任何人都可以自己生成一对公钥和私钥，他只要向“客户”发送他自己的私钥就可以冒充“服务器”了。

```
客户”->“黑客”：你好                             //黑客截获“客户”发给“服务器”的消息
“黑客”->“客户”：你好，我是服务器，这个是我的公钥    //黑客自己生成一对公钥和私钥，把公钥发给“客户”，自己保留私钥
“客户”->“黑客”：向我证明你就是服务器

//客户收到“黑客”用私钥加密的信息后，是可以用“黑客”发给自己的公钥解密的，从而会误认为“黑客”是“服务器”
“黑客”->“客户”：你好，我是服务器 {你好，我是服务器}[黑客自己的私钥|RSA]
```

问题的根源就在于，大家都可以生成公钥、私钥对，无法确认公钥对到底是谁的。 如果能够确定公钥到底是谁的，就不会有这个问题了。  
例如，如果收到“黑客”冒充“服务器”发过来的公钥，经过某种检查，如果能够发现这个公钥不是“服务器”的就好了。

为了解决这个问题，数字证书出现了，它可以解决上面的问题。
`See 1.5`

## 1.5 第五回合：

- Step1： “客户”向服务端发送一个通信请求

```
“客户”->“服务器”：你好
```

- Step 2: “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有.

```
// 这里用证书代替了公钥
“服务器”->“客户”：你好，我是服务器，这是我的数字证书
```

- step3： “客户”收到“服务器”的证书,并确认对方是否是“服务器”

  “客户”收到“服务器”的证书后，它会去验证这个数字证书到底是不是“服务器”的，数字证书有没有什么问题，数字证书如果检查没有问题，就说明数字证书中的公钥确实是“服务器”的。

  检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。

```
// 前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。
“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串
“服务器”->“客户”：{一个随机字符串}[私钥|RSA]
```

- step4： 验证“服务器”的身份后，“客户”生成一个对称加密算法和密钥，用于后面的通信的加密和解密。

  这个对称加密算法和密钥，“客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。这样，后面“服务器”和“客户”就都可以用对称加密算法来加密和解密通信内容了。

```
“客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]
“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]
“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]
“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]
…… //继续其它的通信
```

# 1.7 其它问题：

上面的过程已经十分接近 HTTPS 的真实通信过程了，完全可以按照这个过程去理解 HTTPS 的工作原理。

细节补充：

- 【问题 1】  
  上面的通信过程中说到，在检查完证书后，“客户”发送一个随机的字符串给“服务器”去用私钥加密，以便判断对方是否真的持有私钥。但是有一个问题，“黑客”也可以发送一个字符串给“服务器”去加密并且得到加密后的内容，这样对于“服务器”来说是不安全的，因为黑客可以发送一些简单的有规律的字符串给“服务器”加密，从而寻找加密的规律，有可能威胁到私钥的安全。所以说，“服务器”随随便便用私钥去加密一个来路不明的字符串并把结果发送给对方是不安全的。

  〖解决方法〗  
   每次收到“客户”发来的要加密的的字符串时，“服务器”并不是真正的加密这个字符串本身，而是把这个字符串进行一个 hash 计算，加密这个字符串的 hash 值(不加密原来的字符串)后发送给“客户”，“客户”收到后解密这个 hash 值并自己计算字符串的 hash 值然后进行对比是否一致。也就是说，“服务器”不直接加密收到的字符串，而是加密这个字符串的一个 hash 值，这样就避免了加密那些有规律的字符串，从而降低被破解的机率。“客户”自己发送的字符串，因此它自己可以计算字符串的 hash 值，然后再把“服务器”发送过来的加密的 hash 值和自己计算的进行对比，同样也能确定对方是否是“服务器”。

- 【问题 2】  
   在双方的通信过程中，“黑客”可以截获发送的加密了的内容，虽然他无法解密这个内容，但是他可以捣乱，例如把信息原封不动的发送多次，扰乱通信过程。

  〖解决方法〗  
   可以给通信的内容加上一个序号或者一个随机的值，如果“客户”或者“服务器”接收到的信息中有之前出现过的序号或者随机值，那么说明有人在通信过程中重发信息内容进行捣乱，双方会立刻停止通信。有人可能会问，如果有人一直这么捣乱怎么办？那不是无法通信了？ 答案是的确是这样的，例如有人控制了你连接互联网的路由器，他的确可以针对你。但是一些重要的应用，例如军队或者政府的内部网络，它们都不使用我们平时使用的公网，因此一般人不会破坏到他们的通信。

- 【问题 3】  
  在双方的通信过程中，“黑客”除了简单的重复发送截获的消息之外，还可以修改截获后的密文修改后再发送，因为修改的是密文，虽然不能完全控制消息解密后的内容，但是仍然会破坏解密后的密文。因此发送过程如果黑客对密文进行了修改，“客户”和“服务器”是无法判断密文是否被修改的。虽然不一定能达到目的，但是“黑客”可以一直这样碰碰运气。

  〖解决方法〗  
   在每次发送信息时，先对信息的内容进行一个 hash 计算得出一个 hash 值，将信息的内容和这个 hash 值一起加密后发送。接收方在收到后进行解密得到明文的内容和 hash 值，然后接收方再自己对收到信息内容做一次 hash 计算，与收到的 hash 值进行对比看是否匹配，如果匹配就说明信息在传输过程中没有被修改过。如果不匹配说明中途有人故意对加密数据进行了修改，立刻中断通话过程后做其它处理。

# 2 数字证书

## 2.1 数字证书的构成

```
一个证书包含下面的具体内容：
证书的发布机构
证书的有效期
公钥
证书所有者（Subject）
签名所使用的算法
指纹以及指纹算法
```

数字证书可以保证数字证书里的公钥确实是这个证书的所有者(Subject)的，或者证书可以用来确认对方的身份。

See a Certificate in Window:

![Certificate_build](https://yingvickycao.github.io/img/Certificate_build.png)

certificate authority (CA)：证书的发布机构

| Item                                         | 中文         | DESC                                                    |
| -------------------------------------------- | ------------ | ------------------------------------------------------- |
| Signature                                    | 签名         | 使用签名算法处理签名的信息，得到一个 Hash 值            |
| Signature algorithm                          | 签名算法     | 签名所使用的算法。现在是 `SHA-256 RSA`                  |
| Issuer                                       | CA           | 谁创建并颁布了该证书                                    |
| Valid from - Valid to                        | 证书有效时间 | 过期，不能使用                                          |
| Public key                                   | 公钥         | 2048 位。用来对消息进行加密。Mac 查看时不显示该项 Value |
| Subject                                      | 主题         | 证书发布给谁？也就是谁在使用                            |
| Thumbprint / Fingerprints                    | 指纹         | certificate information 的 hash 值。                    |
| Thumbprint algorithm /Fingerprints algorithm | 指纹算法     | 一个 Hash 算法。用来计算整个证书的 hash 值（即指纹）    |
|                                              |              |                                                         |

> The `Fingerprints` shown below the certificate information in Chrome are not part of the certificate itself, but are independently-calculated hashes that can be used to uniquely identify a certificate.

[faq-x.509-06](https://cdn.ssl.com/wp-content/uploads/2019/09/faq-x.509-06.png)

- Thumbprint, Thumbprint algorithm  
  用来确保证书没有被修改过，作用和 1.7 中说到的第 3 个问题类似。

  其原理就是在发布证书时，发布者根据指纹算法(一个 hash 算法)计算整个证书的 hash 值(指纹)并和证书放在一起。

  `使用者在打开证书时，根据指纹算法计算一下证书的 hash 值(指纹)，如果和刚开始的值对得上，就说明证书没有被修改过，因为证书的内容被修改后，根据证书的内容计算的出的 hash 值(指纹)是会变化的。`

  这个指纹会使用"SecureTrust CA"这个证书机构的私钥用签名算法(Signature algorithm)加密后和证书放在一起。

> 为了保证安全，在证书的发布机构发布证书时，证书的指纹和指纹算法，都会加密后再和证书放到一起发布，以防有人修改指纹后伪造相应的数字证书。  
> 这里问题又来了，证书的指纹和指纹算法用什么加密呢？他们是用证书发布机构的私钥进行加密的。可以用证书发布机构的公钥对指纹和指纹算法解密，也就是说证书发布机构除了给别人发布证书外，他自己本身也有自己的证书。证书发布机构的证书是哪里来的呢？  
> 这个证书发布机构的数字证书(一般由他自己生成)在我们的操作系统刚安装好时(例如 windows xp 等操作系统)，这些证书发布机构的数字证书就已经被微软(或者其它操作系统的开发机构)安装在操作系统中了，微软等公司会根据一些权威安全机构的评估选取一些信誉很好并且通过一定的安全认证的证书发布机构，把这些证书发布机构的证书默认就安装在操作系统里面了，并且设置为操作系统信任的数字证书。这些证书发布机构自己持有与他自己的数字证书对应的私钥，他会用这个私钥加密所有他发布的证书的指纹作为数字签名。

## 2.2 如何向证书的发布机构去申请证书

e.g., 我们公司"ABC Company"花了 1000 块钱，向一个证书发布机构"SecureTrust CA"为我们公司"ABC Company"申请了一张证书.  
这个证书发布机构"SecureTrust CA"是一个大家公认并被一些权威机构接受的证书发布机构，我们的操作系统里面已经安装了"SecureTrust CA"的证书。  
"SecureTrust CA"在给我们发布证书时，把 Issuer,Public key,Subject,Valid from,Valid to 等信息以明文的形式写到证书里面，  
然后用一个指纹算法计算出这些数字证书内容的一个指纹，并把指纹和指纹算法用自己的私钥进行加密，然后和证书的内容一起发布，同时"SecureTrust CA"还会给一个我们公司"ABC Company"的私钥给到我们。

我们花了 1000 块钱买的这个证书的内容如下：

```
××××××××××××××× 证书内容开始 ×××××××××××××××××
Issuer : SecureTrust CA
Subject : ABC Company
Valid from ： 某个日期
Valid to： 某个日期
Public Key : 一串很长的数字
…… 其它的一些证书内容……

{证书的指纹和计算指纹所使用的指纹算法}[SecureTrust CA 的私钥|RSA] //这个就是"SecureTrust CA"对这个证书的一个数字签名，表示这个证书确实是他发布的，有什么问题他会负责(收了我们 1000 块，出了问题肯定要负责任的)
××××××××××××××× 证书内容结束 ×××××××××××××××××
```

`// {} 表示RSA加密后的内容，[ | ]表示用什么密钥和算法进行加密`

---

我们"ABC Company"申请到这个证书后，我们把证书投入使用，我们在通信过程开始时会把证书发给对方，对方如何检查这个证书的确是合法的并且是我们"ABC Company"公司的证书呢？

首先应用程序(对方通信用的程序，例如 IE、OUTLook 等)读取证书中的 Issuer(发布机构)为"SecureTrust CA" ，然后会在操作系统中受信任的发布机构的证书中去找"SecureTrust CA"的证书，如果找不到，那说明证书的发布机构是个水货发布机构，证书可能有问题，程序会给出一个错误信息。

如果在系统中找到了"SecureTrust CA"的证书，那么应用程序就会从证书中取出"SecureTrust CA"的公钥，然后对我们"ABC Company"公司的证书里面的指纹和指纹算法用这个公钥进行解密，然后使用这个指纹算法计算"ABC Company"证书的指纹，将这个计算的指纹与放在证书中的指纹对比，

如果一致，说明"ABC Company"的证书肯定没有被修改过并且证书是"SecureTrust CA" 发布的，证书中的公钥肯定是"ABC Company"的。对方然后就可以放心的使用这个公钥和我们"ABC Company"进行通信了。

## 2.3 证书的发布机构

实所有的公司都可以发布证书，我们自己也可以去注册一家公司来专门给别人发布证书。但是很明显，我们自己的专门发布证书的公司是不会被那些国际上的权威机构认可的.因此微软在它的操作系统中，并不会信任我们这个证书发布机构，当应用程序在检查证书的合法信的时候，一看证书的发布机构并不是操作系统所信任的发布机构，就会抛出错误信息。也就是说 windows 操作系统中不会预先安装好我们这个证书发布机构的证书，不信任我们这个发布机构。

- 不受信任的证书发布机构的危害

为什么一个证书发布机构受不受信任这么重要？我们举个例子。假设我们开了一个狗屁公司来为别人发布证书，并且我和微软有一腿，微软在他们的操作系统中把我设置为了受信任的证书发布机构。现在如果有个小公司叫 Wicrosoft 花了 10 块钱让我为他们公司申请了一个证书，并且公司慢慢壮大，证书的应用范围也越来越广。

然后有个奸商的公司 JS Company 想冒充 Wicrosoft，于是给了我￥ 10000，让我为他们颁布一个证书，但是证书的名字(Subject)要写 Wicrosoft，假如我为了这￥ 10000，真的把证书给了他们，那么他们以后就可以使用这个证书来冒充 Wicrosoft 了。

如果是一个优秀的证书发布机构，比如你要向他申请一个名字叫 Wicrosoft 的证书，它会让你提供很多资料证明你确实可以代表 Wicrosoft 这个公司，也就是说他回去核实你的身份。证书发布机构是要为他发布出的证书负法律责任的。

我们自己也可以成立证书发布机构，但是需要通过一些安全认证等等，只是有点麻烦。另外，如果数字证书只是要在公司内部使用，公司可以自己给自己生成一个证书，在公司的所有机器上把这个证书设置为操作系统信任的证书发布机构的证书(这句话仔细看清楚，有点绕口)，这样以后公司发布的证书在公司内部的所有机器上就可以通过验证了(在发布证书时，把这些证书的 Issuer(发布机构)设置为我们自己的证书发布机构的证书的 Subject(主题)就可以了)。但是这只限于内部应用，因为只有我们公司自己的机器上设置了信任我们自己这个所谓的证书发布机构，而其它机器上并没有事先信任我们这个证书发布机构，所以在其它机器上，我们发布的证书就无法通过安全验证。

## 3.2 如何自己创建证书

Windows 用 makecert。  
Mac 用 keytool。

# Refs

- https://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html

# 数据类型

# 1 基本数据类型：int，float，double，char

- int  
  short int, int, long int, long long int.

  最大值与机器相关，32 位或 64 位

  无论是浮点、整数、还是浮点数字，它对应的值域与系统位特定类型的值所分配的内存量有关。  
  一般来说，在语言中没有规定这个量，它通常依赖于所运行的计算机，因此，叫做设备或机器相关量。

  一个整数可以在计算机上占用 32 位或 64 位。  
  TODO：自动分配，还是固定分配？

- 浮点数

  float

  double  
  double 的存储范围大概是 float 的 2 倍。  
  double, long double, long long double.  
  在计算机内存中不能精确地表示一些浮点值,e.g., 1/3 = 0.33333333

- char

- id 类型
  id 数据类型可以存储类型的对象。它是一个一般对象类型。
  e.g.,

  ```c
  // 声明方法可返回具有id类型的返回值。
  -(id) newObjct:(int) type;
  ```

  id 类型是经常使用的一种重要的数据类型。id 类型是 Object-C 中十分重要的特性，它是多态和动态绑定的基础。

- bool

## 限定词

| 通配符   | 描述                                                                                                        |
| -------- | ----------------------------------------------------------------------------------------------------------- |
| %@       | 对象                                                                                                        |
| %d,%i    | 整型 (%i 的老写法)                                                                                          |
| %hd      | 短整型                                                                                                      |
| %ld,%lld | 长整型                                                                                                      |
| %u       | 无符整型                                                                                                    |
| %f       | 浮点型和 double 型                                                                                          |
| %0.2f    | 精度浮点数，只保留两位小数                                                                                  |
| %x:      | 为 32 位的无符号整型数(unsigned int),打印使用数字 0-9 的十六进制,小写 a-f;                                  |
| %X:      | 为 32 位的无符号整型数(unsigned int),打印使用数字 0-9 的十六进制,大写 A-F;                                  |
| %o       | 八进制                                                                                                      |
| %zu      | size_t                                                                                                      |
| %p       | 指针地址                                                                                                    |
| %e       | float/double （科学计算）                                                                                   |
| %g       | float/double （科学技术法）                                                                                 |
| %s       | char \* 字符串                                                                                              |
| %.\*s    | Pascal 字符串                                                                                               |
| %c       | char 字符                                                                                                   |
| %C       | unichar                                                                                                     |
| %Lf      | 64 位 double                                                                                                |
| %lu      | sizeof(i)内存中所占字节数                                                                                   |
| CGRect   | NSLog(@”%@”,NSStringFromCGRect(someCGRect)); 或者 CFShow(NSStringFromCGRect(someCGRect));CFShow 能打印地址. |
| CGSize   | NSLog(@”%@”,NSStringFromCGSize(someCG Size ));                                                              |

![oc_basic_data_type](https://yingvickycao.github.io/img/ios/oc_basic_data_type.jpg)

# 2 对象的初始化

`_3_data_type/Fraction_3.m`

- 常见的编程习惯：类中所有的初始化方法都以 init 开头。

- 编写初始化方法时，应该遵守 2 个策略：  
  (1) If 在类对象初始化时做一些事情。例如，创建类的对象时需要使用和引用一个或多个实例变量，比如 Rectangle 类。可以通过重载 init 方法达到这个目的。

重载 init 的一个标准“模版”：

```c
-(instancetype) init
{
  // 调用父类的初始化方法。执行父类的初始化方法，使得继承的实例变量能够正常初始化。
  // 因为初始化过程改变了对象在内存中的位置，即引用将要改变，因此必须将父类init方法的执行结果赋值给self。
  self = [super init];

  // If 父类的初始化过程成功，则返回值为非0.
  if(self){
    // 初始化代码：可以自定义初始化代码。通常用来创建并初始化实例变量。
  }

  return self;
}
```

(2) If 类包含多个初始化方法，其中一个就应该指定的(designated)初始化方法，并且其他所有的初始化方法都应该使用这个方法。通常，它是最复杂的初始化方法（一般是参数最多的初始化方法）。通过创建指定的初始化方法，把大部分初始化代码集中到单个方法中。然后，这个类的派生子类，都可以重载这个指定的初始化方法，以保证正确地初始化新的实例。

```c
// _3_data_type/Fraction_3.m

// 为了使用指定的初始化方法，需要修改init方法。
-(instancetype) init{
    return [self initWith:0 over:0];
}

// 指定的初始化方法
- (Fraction_3 *)initWith:(int)n over:(int)d{
  self = [super init];
  if (self) {
      [self setTo:n over:d];
  }
  return self;
}
```

# 3 作用域

使用多种方式影响程序中变量的作用域。
改变实例变量及定义在函数外部或内部的普通变量的作用域。
使用模块（module）来引用或包含一个源文件中任何数目的方法或函数定义。

## 属性、存取方法和实例变量

- 惯例：实例变量名以`_`开头。
- `@synthesize`指令发生了什么？

```c
// 表明合成（synthesize）属性window的取值方法和设置方法，并将属性与实例变量_window（实例变量并没有显式声明）关联起来。
// TODO: window 属性到底是个什么东西？与实例变量的区别？
@synthesize window = _window;
```

作用域：在实现部分显式声明的实例变量，或使用`@synthesize`指令隐式声明的实例变量，是私有的。即：子类不能直接通过名字直接获取实例变量，只能通过取值方法来获取。

## 全局变量

`_3_3_main_4_global.m`

作用域：模块的任何地方，以及其他文件都可以引用这个全局变量。任何方法都可以访问和更改全局变量。

- 惯例：以 g 开头来命名全局变量。

```c
int gNumber;
```

- 外部全局变量

```c
// 声明我要访问全局变量gGlobalVar
// Recommened :
extern int gGlobalVar;
gGlobalVar = val;

// Warning:
// 关键字 extern 表明这条语句是变量的声明，不是定义。声明不会引起变量存储空间分配，而定义会。
// 因此，强行将声明当作定义处理（通过指派初始值），所以违背了这个原则。
extern int gGlobalVar = val;
```

- 在方法外定义的变量不仅是全局变量，而且是外部变量。
- 使用外部变量时遵循的原则：  
(1) 变量必须定义在源文件的某个位置。即所有的方法和函数之外声明变量，且前面不加关键字 extern。  
(2）确定外部变量的第二种方式是，在所有的函数之外声明变量，在声明前加关键字 extern ，同时显式地为变量指派初始化。  
(3) 处理外部变量时，变量可以在多个地方声明为 extern，但是只能定义一次。  
(4) 如果一个文件中有很多地方需要访问 全局变量 gGlobalVar，只在文件的开始进行一次 extern 声明比较简单。  
如果只有一个或少数几个方法要访问这个变量，应该在其中的每个方法中单独进行 extern 声明。好处：程序的组织结构更加清晰，并且实际使用到变量的不同函数可以单独使用这个变量。    
如果变量定义在包含访问这个变量的文件中，那么不需要单独进行 extern 声明。

## 静态变量

`_3_3_main_4_static.m`

```c
// 在该文件中，所有位于这条语句的方法都可以访问该变量，但其他文件中的方法和函数则不可以。
static int gCounter;  // 定义

// 访问
// 类方法
// 继承而来的allocfan 没有被重载，而是定义了自己的分配器方法。重载alloc不是好的编程，因为这个方法要处理内存的物理分配。
+ (Foo *) allocF{
    // 因为定在该文件中，因此，不需要在此方法中使用 extern 声明。声明是为了阅读方法的人明白，访问的变量是定义在方法之外。g前缀也出于同样的目的。因此，大多数程序员一般不使用 extern 声明。
//    extern int gCounter;
    ++gCounter;
    //
    return [Foo alloc];
}
```

- 在方法外定义的静态变量是全局变量，但不是外部变量。
- 虽然是全局变量，但是只能在特定模块或文件中是全局的。即除了特定类的方法之外 ，没有其他方法需要访问这个特定类的变量。
- 静态变量不需要初始化，自动置为默认初始值。也可以使用实例方法或类方法设置值。

- 作用域：  
  (1) 定义为静态变量之后，使得定义在执行文件中的方法可以访问它，但是文件之外都不可以访问。  
  (2) 类方法不能访问实例变量，但实例方法可以访问静态变量。

# 4 枚举数据类型
- 枚举标识符作为整型常量来处理。
- 定义枚举类型时，确保枚举类型标识符与定义在相同作用域之内的变量名和其他标识符不同。

# 5 typedef 语句
typedef 为数据类型另外指定一个名称

# 6 数据类型转换
表达式会进行隐式的数据类型转换，使用转换符显式强制类型转换，从而控制表达式的求值。

对于含有不同类型的表达式，Objective-C遵循的规则：  
![oc_implicit_type_convertion](https://yingvickycao.github.io/img/ios/oc_implicit_type_convertion.jpg)

# 表达式

- 使用括号改变表达式的计算顺序。
- 整数和浮点数的相互转换
  对于处理任何两个值的运算，只要表达式中的两个运算符是整型，那么，该运算在整数运算的规则下进行。因此，运算产生的任何小数部分都将被删除。即使被赋给一个浮点变量也是如此。  
  对于处理任何两个值的运算，如果其中一个是浮点运算或常量，那么，该运算将作为浮点运算来处理。

# 运算符的种类

- 算数运算符
- 模运算符
- 类型转换运算符
- 强制类型转换符
- 关系运算符
- 复合运算符(&&, ||)
- 位运算符
- 地址运算符(`&`)、间接寻址运算符(`*`)、结构指针运算符(`->` 或 `(*).`)

## 位运算符

`_4_main_for_byte_operator.m`  
![oc_byte_operator](https://yingvickycao.github.io/img/ios/oc_byte_operator.jpg)

- 按位与
  位都是 1，则 1，否则 0。  
  经常用于屏蔽运算。该运算符可轻易把数据项的特定位置设为 0. e.g., w3=w1 & 3;
  ![oc_byte_and](https://yingvickycao.github.io/img/ios/oc_byte_and.jpg)

- 按位或
  位有一个是 1，则 1，否则 0。  
  ![oc_byte_or](https://yingvickycao.github.io/img/ios/oc_byte_or.jpg)

- 按位异或  
  任何一位是 1，但两者都不是 1，则 1，否则 0.  
  ![oc_byte_XOR](https://yingvickycao.github.io/img/ios/oc_byte_XOR.jpg)

- 一次求反  
  按位取反。  
  ![oc_byte_Inverse](https://yingvickycao.github.io/img/ios/oc_byte_Inverse.jpg)

- 向左移位
  超出数据项的高位的将丢失，从低位移入的值总为 0；

- 向右移位  
  从值的低位移出的位将丢失。

  将无符号的值，总是左侧（高位）移入 0.

  将有符号的值，左侧移入 1 还是 0，取决于被移动数字的符号，还取决于该操作在计算机上的实现方式。如果符号位是 0（正值），不管哪种机器，都将移入 0. 如果符号是 1，那么在一些机器上将移入 1（算数右移），其他机器则移入 0（逻辑右移）.

  如果试图将大于或等于该数据项的位数将值向左或向右移动，那么 Objective-c 对结果没有移动。因为，计算机用 64 位表示整数，那么把一个整数向左移动或向右移动 64 位或更多位时，不能保证得到确定的结果。如果使用负数对值移位，结果将同样是未定义的。

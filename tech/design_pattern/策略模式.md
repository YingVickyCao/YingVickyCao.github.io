# 策略模式 - 封装算法

# 策略模式

> 策略模式（Strategy Pattern）：
> 定义算法族，分别封装起来，让它们之间互相替换，此模式让算法的变化独立于使用算法的客户。

使用场景：随着需求的变化，超类中添加的某些行为在某些子类中不具备

策略模式典型的使用例子：
游戏中不同的游戏角色使用不同的武器。

# Sample

随着需求的变化，Duck 超类中添加的某些行为在某些子类中不具备

## 方法 1:使用继承

评价：  
随着需求增加，Duck 超类中 fly and quack 行为在某些子类中不具备。  
每当新类型 Duck 出现时，被迫检查并可能需要覆盖 fly() and quack().如果行为很多（40~50），需要变动的行为可能会很多。

![Strategy_Pattern_duck_1](https://yingvickycao.github.io/img/Strategy_Pattern_duck_1.png)

![Strategy_Pattern_duck_2](https://yingvickycao.github.io/img/Strategy_Pattern_duck_2.png)

![Strategy_Pattern_duck_3](https://yingvickycao.github.io/img/Strategy_Pattern_duck_3.png)

## 方法 2:使用接口

评价：
使用接口，可以解决一部分问题（不适合的行为），但会造成代码无法复用：  
Java 接口不具有实现代码，所有继承接口无法达到代码复用。

适合：行为接口很少，子类很少  
不适合：行为接口很多，子类很多

![Strategy_Pattern_duck_4](https://yingvickycao.github.io/img/Strategy_Pattern_duck_4.png)

## 方法 3:使用策略模式

将 fly and quack 行为`委托（delegate）`别的类处理，而不是直接定义在 Duck 或子类中。  
使用 setter 方法，动态设定行为。  
使用它，隔离变化，系统不担心遇到任何变化

![Strategy_Pattern_duck_5](https://yingvickycao.github.io/img/Strategy_Pattern_duck_5.png)

![Strategy_Pattern_duck_6](https://yingvickycao.github.io/img/Strategy_Pattern_duck_6.png)

---

- 应用中需要修改代码的原因？
  客户需要别的东西  
  新功能  
  bugfix  
  重构
- 软件开发所花费时间：完成“前”< 完成“后”  
  软件开发完成“前”：致力于提高开发速度。  
  软件开发完成“后”：致力于提高可维护性和可扩展性的复用程度。

- 模式让开发人员之间有共享的语言，能够更大化沟通的价值。  
  设计模式让你和其他开发人员之间共享词汇，使沟通变得容易。

  共享词汇：
  **共享的模式词汇“威力强大”。**  
   沟通时不仅仅是模式名称，而是一整套模式背后所象征的质量、特征、约束

  **将说话的方式保持在模式层次上，可以让待在“设计圈子”久一点。**  
   使用模式谈论软件系统，可以让你保持在设计层次，不会压低到对象与类这种琐碎的对象上。  
   即：设计模式把思考架构的层次提高到模式层面，而不是仅仅停留在琐碎的对象上。

  **帮组团队快速充电。**  
   对设计模式深入了解，彼此之间对设计的看法不容易产生误解

  **帮助初级开发人员迅速成长。**  
   初级向使用模式的高级学习，把组织建立成一个模式使用者的社区。

- 如何使用设计模式？  
  库与框架能编译成程序，但无法帮助将应用组织成容易了解、容易维护、具有弹性的架构，所以需要设计模式。  
  设计模式不会直接进入代码，而是先进入你的大脑中。一旦在大脑中装入许多关于模式的知识。就能够在新设计中使用它们，并当旧代码变得没有弹性，可用重做旧代码。

![Strategy_Pattern_duck_7](https://yingvickycao.github.io/img/Strategy_Pattern_duck_7.png)

- 设计模式 vs 库和框架  
  设计模式比库高级。  
  库和框架不是设计模式，但本身使用了设计模式。了解设计模式，会更容易了解设计模式是如何构造 API。  
  设计模式告诉我们如何组织代码类和对象以解决某种问题，采用这些设计并使它们适合我们特定的应用。
- 知道 OO 基础，并不足以让设计出良好的 OO 系统。
- 良好的 OO 设计必须具备复用、可扩充、可维护三个特征。  
  即：弹性、可以维护、可以应付变化
- 建立可维护的 OO 系统，要诀在于随时想到系统以后可能需要的变化，以及可能应付变化的原则。
- 模式可以让建造出具备良好 OO 设计质量的系统。
- 模式被认为是历经验证的 OO 设计经验
- 模式不是代码，而是针对设计问题的通用解决方案。
- 模式不是被发明，而是被发现。
- 软件开发中什么不变？  
  Change
- 大多数的模式和原则，都着眼于软件变化的主题。
- 大多数的模式都允许系统局部改变独立于其他部分。
- 常把系统中变化的部分抽离出来
- 如果找不到模式，怎么办？  
  有一些面对对象原则，适合所有的模式。  
  当无法找到适当的模式解决问题时，采用这些原则。
- 原则和模式可以应用在软件生命周期的任何阶段。
- 原则很重要，每个设计模式包含了几个 OO 原则。
- OO 原则是目标，设计模式是做法。
- 尽量达到这些原则，而不是随时要遵守这些原则。

<h1 id="design_principles_1">原则 1：封装变化。</h1>

> 原则 1：找出应用中可能需要变化之处，把他们独立出来并封装，不要和那些不需要变化的代码混在一起，好让其他部分不会受到影响。

分开变化和不变化的部分->让 系统中某部分变化不影响其他部分：  
如果要增加新的需求，都会使得某方面的代码发生变化，那么可以确定：这部分代码需要被抽出来，和其他稳定的代码区分开来。
把会变化的部分取出并封装出来，是为了可以轻易地改动或扩充次部分，而不影响不需要变化的其他部分。

<h1 id="design_principles_2">原则 2：多用组合（composition），少用继承。</h1>  
组合不同于继承的地方：鸭子的行为不是继承而来的，而是和适当的行为对象“组合”来的。  
为了实现“在运行时动态地改变行为”，提供相应的 set 方法。  
使用组合建立系统具有弹性，不仅仅将算法族封装成类，更可以“在运行时动态地改变行为”，只要组合的行为对象符合正确的接口标准即可。

<h1 id="design_principles_3">原则 3：针对接口编程，而不是针对实现编程。</h1>  
由行为类而不是 Duck 类实现接口行为。
针对接口编程的关键在于多态：变量的声明类型应该是超类型，通常是一个抽象类或者是一个接口。
利用多态，针对超类型编程，执行时会根据实际情况执行真正的行为，不会绑定到超类型的行为。
